import { ActorPF2e } from "@actor";
import { FeatGroup } from "@actor/character/feats.ts";
import { MODIFIER_TYPES, ModifierPF2e, RawModifier, createProficiencyModifier } from "@actor/modifiers.ts";
import { CampaignFeaturePF2e, ItemPF2e } from "@item";
import { ItemType } from "@item/data/index.ts";
import { Statistic } from "@system/statistic/index.ts";
import { ErrorPF2e, createHTMLElement, fontAwesomeIcon, objectHasKey, setHasElement } from "@util";
import * as R from "remeda";
import type { PartyPF2e } from "../document.ts";
import { PartyCampaign } from "../types.ts";
import { KingdomBuilder } from "./builder.ts";
import { resolveKingdomBoosts } from "./helpers.ts";
import { KINGDOM_SCHEMA } from "./schema.ts";
import { KingdomSheetPF2e } from "./sheet.ts";
import {
    KingdomCHG,
    KingdomGovernment,
    KingdomNationType,
    KingdomSchema,
    KingdomSkill,
    KingdomSource,
} from "./types.ts";
import {
    CONTROL_DC_BY_LEVEL,
    KINGDOM_ABILITIES,
    KINGDOM_ABILITY_LABELS,
    KINGDOM_LEADERSHIP,
    KINGDOM_LEADERSHIP_ABILITIES,
    KINGDOM_RUIN_LABELS,
    KINGDOM_SIZE_DATA,
    KINGDOM_SKILLS,
    KINGDOM_SKILL_ABILITIES,
    KINGDOM_SKILL_LABELS,
    VACANCY_PENALTIES,
} from "./values.ts";

const { DataModel } = foundry.abstract;

/** Model for the Kingmaker campaign data type, which represents a Kingdom */
class Kingdom extends DataModel<PartyPF2e, KingdomSchema> implements PartyCampaign {
    declare nationType: KingdomNationType;
    declare features: FeatGroup<PartyPF2e, CampaignFeaturePF2e>;
    declare feats: FeatGroup<PartyPF2e, CampaignFeaturePF2e>;
    declare bonusFeats: FeatGroup<PartyPF2e, CampaignFeaturePF2e>;
    declare skills: Record<KingdomSkill, Statistic>;
    declare control: Statistic;

    static override defineSchema(): KingdomSchema {
        return KINGDOM_SCHEMA;
    }

    get actor(): PartyPF2e {
        return this.parent;
    }

    get extraItemTypes(): ItemType[] {
        return ["campaignFeature"];
    }

    get activities(): CampaignFeaturePF2e[] {
        return this.actor.itemTypes.campaignFeature.filter((k) => k.category === "kingdom-activity");
    }

    get charter(): KingdomCHG | null {
        return this.build.charter;
    }

    get heartland(): KingdomCHG | null {
        return this.build.heartland;
    }

    get government(): KingdomGovernment | null {
        return this.build.government;
    }

    override _initialize(options?: Record<string, unknown>): void {
        super._initialize(options);
        this.prepareData();
    }

    /** Creates sidebar buttons to inject into the chat message sidebar */
    createSidebarButtons(): HTMLElement[] {
        // Do not show kingdom to party members until it becomes activated.
        if (!this.active && !game.user.isGM) return [];

        const crownIcon = fontAwesomeIcon("crown");
        const icon = createHTMLElement("a", { classes: ["create-button"], children: [crownIcon] });
        if (!this.active) {
            icon.appendChild(fontAwesomeIcon("plus"));
        }

        icon.addEventListener("click", (event) => {
            event.stopPropagation();
            const type = this.active ? null : "builder";
            this.renderSheet({ type });
        });
        return [icon];
    }

    async collect(): Promise<void> {
        // todo: implement
    }

    /**
     * Adds a custom modifier that will be included when determining the final value of a stat. The slug generated by
     * the name parameter must be unique for the custom modifiers for the specified stat, or it will be ignored.
     */
    async addCustomModifier(stat: string, data: RawModifier): Promise<void> {
        if (stat.length === 0) throw ErrorPF2e("A custom modifier's statistic must be a non-empty string");
        if (data.label.length === 0) throw ErrorPF2e("A custom modifier's label must be a non-empty string");

        const customModifiers = this.toObject().customModifiers ?? {};
        const modifiers = customModifiers[stat] ?? [];
        if (!modifiers.some((m) => m.label === data.label)) {
            data.type = setHasElement(MODIFIER_TYPES, data.type) ? data.type : "untyped";
            const modifier = new ModifierPF2e({ ...data, custom: true }).toObject();
            await this.update({ [`customModifiers.${stat}`]: [...modifiers, modifier] });
        }
    }

    /** Removes a custom modifier by slug */
    async removeCustomModifier(stat: string, slug: string): Promise<void> {
        if (stat.length === 0) throw ErrorPF2e("A custom modifier's statistic must be a non-empty string");

        const customModifiers = this.toObject().customModifiers ?? {};
        const modifiers = customModifiers[stat] ?? [];
        if (modifiers.length === 0) return;

        if (typeof slug === "string") {
            const withRemoved = modifiers.filter((m) => m.slug !== slug);
            await this.update({ [`customModifiers.${stat}`]: withRemoved });
        } else {
            throw ErrorPF2e("Custom modifiers can only be removed by slug (string) or index (number)");
        }
    }

    async update(data: DeepPartial<KingdomSource> & Record<string, unknown>): Promise<void> {
        await this.actor.update({ "system.campaign": data });

        if (data.level) {
            await this.updateFeatures(data.level);
        }
    }

    prepareData(): void {
        const { synthetics } = this.actor;

        // Calculate Ability Boosts (if calculated automatically)
        if (!this.build.manual) {
            for (const ability of KINGDOM_ABILITIES) {
                this.abilities[ability].value = 10;
            }

            // Charter/Heartland/Government boosts
            for (const category of ["charter", "heartland", "government"] as const) {
                const data = this.build[category];
                const chosen = this.build.boosts[category];
                if (!data) continue;

                if (data.flaw) {
                    this.abilities[data.flaw].value -= 2;
                }

                const activeBoosts = resolveKingdomBoosts(data, chosen);
                for (const ability of activeBoosts) {
                    this.abilities[ability].value += this.abilities[ability].value >= 18 ? 1 : 2;
                }
            }

            // Level boosts
            const activeLevels = ([1, 5, 10, 15, 20] as const).filter((l) => this.level >= l);
            for (const level of activeLevels) {
                const chosen = this.build.boosts[level].slice(0, 2);
                for (const ability of chosen) {
                    this.abilities[ability].value += this.abilities[ability].value >= 18 ? 1 : 2;
                }
            }
        }

        // Assign Ability modifiers base on values
        for (const ability of KINGDOM_ABILITIES) {
            this.abilities[ability].mod = (this.abilities[ability].value - 10) / 2;
        }

        // Bless raw custom modifiers as `ModifierPF2e`s
        const customModifiers = (this.customModifiers ??= {});
        for (const selector of Object.keys(customModifiers)) {
            const modifiers = (customModifiers[selector] = customModifiers[selector].map(
                (rawModifier: RawModifier) => new ModifierPF2e(rawModifier)
            ));
            (synthetics.modifiers[selector] ??= []).push(...modifiers.map((m) => () => m));
        }

        const sizeData =
            Object.entries(KINGDOM_SIZE_DATA).findLast(([size]) => this.size >= Number(size))?.[1] ??
            KINGDOM_SIZE_DATA[1];

        this.nationType = sizeData.type;

        // Autocompute resource dice
        this.resources.dice = mergeObject(this.resources.dice, {
            faces: sizeData.faces,
            number: Math.max(0, this.level + 4 + this.resources.dice.bonus - this.resources.dice.penalty),
        });

        // Inject control dc size modifier
        if (sizeData.controlMod) {
            const modifiers = (synthetics.modifiers["control-dc"] ??= []);
            modifiers.push(
                () =>
                    new ModifierPF2e({
                        slug: "size",
                        label: "Size Modifier",
                        modifier: sizeData.controlMod,
                    })
            );
        }

        // Add any relevant ruin penalties
        for (const ability of KINGDOM_ABILITIES) {
            const penalty = this.abilities[ability].penalty;
            if (penalty) {
                const modifiers = (synthetics.modifiers[`${ability}-based`] ??= []);
                modifiers.push(
                    () =>
                        new ModifierPF2e({
                            slug: "ruin",
                            type: "item",
                            label: KINGDOM_RUIN_LABELS[ability],
                            modifier: penalty,
                        })
                );
            }
        }

        // Auto-set if vacant (for npcs), and inject vacancy penalty modifiers into synthetics
        for (const role of KINGDOM_LEADERSHIP) {
            const data = this.leadership[role];
            const actor = fromUuidSync(data.uuid ?? "");
            if (actor instanceof ActorPF2e) {
                if (!actor.hasPlayerOwner) data.vacant = false;
            } else {
                data.vacant = true;
            }

            if (data.vacant) {
                const penalties = VACANCY_PENALTIES[role]();
                for (const [selector, entries] of Object.entries(penalties.modifiers ?? {})) {
                    const modifiers = (synthetics.modifiers[selector] ??= []);
                    modifiers.push(...entries.map((e) => () => new ModifierPF2e(e)));
                }
            }

            if (data.invested) {
                const ability = KINGDOM_LEADERSHIP_ABILITIES[role];
                const modifiers = (synthetics.modifiers[`${ability}-skill-check`] ??= []);
                modifiers.push(
                    () =>
                        new ModifierPF2e({
                            slug: "invested",
                            label: "PF2E.Kingmaker.Kingdom.Invested",
                            type: "status",
                            modifier: 1,
                        })
                );
            }
        }

        // Compute commodity max values
        for (const value of Object.values(this.resources.commodities)) {
            value.max = sizeData.storage;
        }
    }

    prepareDerivedData(): void {
        // Calculate the control dc, used for skill checks
        const controlMod = CONTROL_DC_BY_LEVEL[Math.clamped(this.level - 1, 0, 19)] - 10;
        this.control = new Statistic(this.actor, {
            slug: "control",
            label: "PF2E.Kingmaker.Kingdom.ControlDC",
            domains: ["control-dc"],
            modifiers: [new ModifierPF2e({ slug: "base", label: "PF2E.ModifierTitle", modifier: controlMod })],
        });

        // Calculate all kingdom skills
        this.skills = R.mapToObj(KINGDOM_SKILLS, (skill) => {
            const ability = KINGDOM_SKILL_ABILITIES[skill];
            const abilityMod = this.abilities[ability].mod;
            const rank = this.build.skills[skill].rank;
            const domains = ["kingdom-check", `${ability}-based`, `${ability}-skill-check`, skill];
            const statistic = new Statistic(this.actor, {
                slug: skill,
                rank,
                label: KINGDOM_SKILL_LABELS[skill],
                domains,
                modifiers: [
                    new ModifierPF2e({
                        slug: ability,
                        label: KINGDOM_ABILITY_LABELS[ability],
                        modifier: abilityMod,
                        type: "ability",
                    }),
                    createProficiencyModifier({ actor: this.actor, rank, domains }),
                ],
                check: { type: "skill-check" },
            });

            return [skill, statistic];
        });

        // Create feat groups
        const evenLevels = new Array(this.level)
            .fill(0)
            .map((_, idx) => idx + 1)
            .filter((idx) => idx % 2 === 0);
        this.features = new FeatGroup(this.actor, {
            id: "features",
            label: "Kingdom Features",
            level: this.level,
        });
        this.feats = new FeatGroup(this.actor, {
            id: "kingdom",
            label: "Kingdom Feats",
            slots: evenLevels,
            featFilter: ["traits-kingdom"],
            level: this.level,
        });
        this.bonusFeats = new FeatGroup(this.actor, {
            id: "bonus",
            label: "PF2E.FeatBonusHeader",
            featFilter: ["traits-kingdom"],
            level: this.level,
        });

        // Assign feats and features
        const allFeatures = this.actor.itemTypes.campaignFeature;
        const features = R.sortBy(
            allFeatures.filter((f) => f.isFeature),
            (f) => f.level ?? 1,
            (f) => f.name
        );
        const feats = R.sortBy(
            allFeatures.filter((f) => f.isFeat),
            (f) => f.sort
        );
        for (const feature of features) {
            this.features.assignFeat(feature);
        }
        for (const feat of feats) {
            if (!this.feats.assignFeat(feat)) {
                this.bonusFeats.assignFeat(feat);
            }
        }
    }

    getRollData(): Record<string, unknown> {
        return { kingdom: this };
    }

    async importActivities({ skipDialog = false }: { skipDialog?: boolean } = {}): Promise<void> {
        const pack = game.packs.get("pf2e.kingmaker-features");
        if (!pack) {
            throw ErrorPF2e("Could not load kingdom features compendium");
        }

        // Add any relevant kingdom features first
        await this.updateFeatures(this.level);

        const documents = (await pack.getDocuments({ type: "campaignFeature" }))
            .filter((d): d is CampaignFeaturePF2e<null> => d instanceof ItemPF2e && d.isOfType("campaignFeature"))
            .filter((d) => d.system.category === "kingdom-activity");

        const actor = this.actor;
        const newDocuments = documents.filter((d) => !actor.items.some((i) => i.sourceId === d.uuid));
        const createData = newDocuments.map((d) => d.toObject());

        const incomingDataByUUID = R.mapToObj(documents, (d) => [d.uuid, d.toObject(true)]);
        const updateData = R.compact(
            actor.itemTypes.campaignFeature.map((d) => {
                const incoming = d.sourceId && incomingDataByUUID[d.sourceId];
                if (!incoming) return null;

                const data = R.pick(incoming, ["name", "img", "system"]);
                const diff = diffObject(d.toObject(true), data);
                return R.isEmpty(diff) ? null : { _id: d.id, ...diff };
            })
        );

        // Exit out early if there's nothing to add or update
        if (!updateData.length && !createData.length) {
            return;
        }

        if (!skipDialog) {
            const result = await Dialog.confirm({
                title: game.i18n.localize("PF2E.Kingmaker.Kingdom.ImportDialog.Title"),
                content: game.i18n.format("PF2E.Kingmaker.Kingdom.ImportDialog.Content", {
                    added: createData.length,
                    updated: updateData.length,
                }),
            });
            if (!result) return;
        }

        await this.actor.updateEmbeddedDocuments("Item", updateData);
        await this.actor.createEmbeddedDocuments("Item", createData);
    }

    /** Adds/removes kingdom features as appropriate. Private instead of # because # explodes */
    private async updateFeatures(level: number): Promise<void> {
        const existingFeatures = this.actor.itemTypes.campaignFeature.filter((f) => f.isFeature);
        const featuresToDelete = existingFeatures.filter((f) => (f.level ?? 0) > level).map((f) => f.id);

        const featuresToAdd = await (async () => {
            const pack = game.packs.get("pf2e.kingmaker-features");
            if (!pack) {
                console.error("PF2E System | Could not load kingdom features compendium");
                return [];
            }

            const documents = (await pack.getDocuments({ type: "campaignFeature" }))
                .filter((d): d is CampaignFeaturePF2e<null> => d instanceof ItemPF2e && d.isOfType("campaignFeature"))
                .filter((d) => d.system.category === "kingdom-feature")
                .filter((d) => level >= (d.level ?? 0));
            return documents
                .filter((d) => !this.actor.items.some((i) => i.sourceId === d.uuid))
                .map((i) => i.toObject());
        })();

        await this.actor.deleteEmbeddedDocuments("Item", featuresToDelete);
        await this.actor.createEmbeddedDocuments("Item", featuresToAdd);
    }

    getStatistic(slug: string): Statistic | null {
        if (this.skills && objectHasKey(this.skills, slug)) {
            return this.skills[slug] ?? null;
        }

        return null;
    }

    renderSheet(options: { tab?: string; type?: "builder" | null } = {}): void {
        if (options.type === "builder") {
            new KingdomBuilder(this).render(true);
        } else {
            new KingdomSheetPF2e(this.actor).render(true, { tab: options.tab });
        }
    }
}

// eslint-disable-next-line @typescript-eslint/no-empty-interface
interface Kingdom extends ModelPropsFromSchema<KingdomSchema> {}

export { Kingdom };
