{
    "_id": "0GU2sdy3r2MeC56x",
    "actorIds": [],
    "author": "4rlSA43v1xPa1vsy",
    "command": "const FAST_RECOVERY = 'Compendium.pf2e.feats-srd.N8Xz5fuW6o7GW124';\nconst DREAM_MAY = 'Compendium.pf2e.feats-srd.kqnFdIhToKTnOpMl';\n\nconst levelMultiplier = (actor) =>\n    actor.items.filter((item) => [FAST_RECOVERY, DREAM_MAY].includes(item.data.flags.core?.sourceId)).length + 1;\n\nconst recover = () => {\n    const Character = CONFIG.PF2E.Actor.entityClasses.character;\n    const Condition = CONFIG.PF2E.Item.entityClasses.condition;\n    const tokens = canvas.tokens.controlled.filter((token) => token.actor instanceof Character);\n\n    if (tokens.length === 0) {\n        ui.notifications.warning('Select at least one token.');\n    }\n\n    for (const token of tokens) {\n        const actor = token.actor;\n        const actorData = duplicate(actor.data);\n        const items = Array.from(actor.items.values());\n        const abilities = actorData.data.abilities;\n        const attributes = actorData.data.attributes;\n\n        // Hit points\n        const conModifier = abilities.con.mod;\n        const level = actorData.data.details.level.value;\n        const maxRestored = Math.max(conModifier, 1) * level * levelMultiplier(actor);\n        const hpLost = attributes.hp.max - attributes.hp.value;\n        const hpRestored = hpLost >= maxRestored ? maxRestored : hpLost;\n        attributes.hp.value += hpRestored;\n\n        // Conditions\n        const conditions = items.filter((item) => item.type === 'condition' && item.getFlag('pf2e', 'condition'));\n        const conditionChanges = {};\n\n        // Fatigued condition\n        const fatigued = conditions.find((item) => item.name === 'Fatigued');\n        if (fatigued instanceof Condition) {\n            PF2eConditionManager.removeConditionFromToken(fatigued.id, token);\n            conditionChanges.Fatigued = null;\n        }\n\n        // Doomed and Drained conditions\n        for (const conditionName of ['Doomed', 'Drained']) {\n            const doomedOrDrained = conditions.find((condition) => condition.name === conditionName);\n            if (doomedOrDrained === undefined) {\n                continue;\n            }\n            const value = doomedOrDrained.data.data.value.value;\n            if (value === 1) {\n                PF2eConditionManager.removeConditionFromToken(doomedOrDrained.id, token);\n                conditionChanges[conditionName] = null;\n            } else {\n                const newValue = value - 1;\n                PF2eConditionManager.updateConditionValue(doomedOrDrained.id, token, newValue);\n                conditionChanges[conditionName] = newValue;\n            }\n        }\n\n        // Restore wand charges\n\n        const wands = items.filter((i) => i.data.data.consumableType?.value === 'wand');\n        let wandRecharged = false;\n        const updateData = wands.map((w) => {\n            return { _id: w.id, 'data.charges.value': parseInt(w.data.data.charges.max) };\n        });\n        if (updateData.length > 0) {\n            wandRecharged = true;\n        }\n\n        // Spellcasting entries\n        const restoredList = [];\n        const entries = items.filter((item) => item.type === 'spellcastingEntry');\n        const entriesUpdateData = entries.flatMap((entry) => {\n            const entryType = entry.data.data.prepared.value ? entry.data.data.prepared.value : 'focus';\n\n            // Focus spells\n            if (entryType === 'focus') {\n                const focusPool = duplicate(entry.data.data.focus);\n                if (focusPool.points < focusPool.pool) {\n                    focusPool.points = focusPool.pool;\n                    restoredList.push('Focus Pool');\n                    return { _id: entry.id, 'data.focus': focusPool };\n                }\n\n                return [];\n            }\n\n            // Innate, Spontaneous, and Prepared spells\n            const slots = entry.data.data.slots;\n            let updated = false;\n            for (const slot of Object.values(slots)) {\n                if (['spontaneous', 'innate'].includes(entryType)) {\n                    if (slot.value < slot.max) {\n                        slot.value = slot.max;\n                        updated = true;\n                    }\n                } else {\n                    for (const preparedSpell of Object.values(slot.prepared)) {\n                        if (preparedSpell.expended) {\n                            preparedSpell.expended = false;\n                            updated = true;\n                        }\n                    }\n                }\n            }\n\n            if (updated) {\n                restoredList.push(entryType === 'focus' ? 'Focus Pool' : `${entry.name} spell slots`);\n                return { _id: entry.id, 'data.slots': slots };\n            }\n            return [];\n        });\n\n        updateData.push(...entriesUpdateData);\n\n        // Stamina points\n        const staminaSetting = game.settings.storage.get('world').get('pf2e.staminaVariant');\n        const staminaEnabled = staminaSetting ? Boolean(parseInt(staminaSetting.replace(/\"/g, ''), 10)) : false;\n\n        if (staminaEnabled) {\n            const stamina = attributes.sp;\n            const keyAbility = actorData.data.details.keyability.value;\n            if (stamina.value < stamina.max) {\n                stamina.value = stamina.max;\n                restoredList.push('Stamina');\n            }\n            const resolve = attributes.resolve;\n            const maxResolve = abilities[keyAbility].mod;\n            if (resolve.value < maxResolve) {\n                resolve.value = maxResolve;\n                restoredList.push('Resolve');\n            }\n        }\n\n        // Updated actor with the sweet fruits of rest\n        if (hpRestored > 0 || restoredList.length > 0) {\n            actor.update({ 'data.attributes': attributes });\n        }\n        if (updateData.length > 0) {\n            actor.updateOwnedItem(updateData);\n        }\n\n        // Construct messages\n        const messages = [`${token.name} awakens well-rested.`];\n\n        // Hit-point restoration\n        if (hpRestored > 0) {\n            messages.push(`${hpRestored} hit points restored.`);\n        }\n\n        // Wand recharge\n        if (wandRecharged) {\n            messages.push('Spellcasting wands recharged.');\n        }\n\n        // Attribute restoration\n        const restoredString =\n            restoredList.length === 0\n                ? ''\n                : restoredList.length === 1\n                ? `${restoredList[0]}`\n                : restoredList.length === 2\n                ? `${restoredList.join(' and ')}`\n                : `${restoredList.slice(0, -1).join(', ')}, and ` + `${restoredList.slice(-1)[0]}`;\n        messages.push(restoredList.length > 0 ? `${restoredString} fully restored.` : null);\n\n        // Condition removal\n        const removedConditions = Object.keys(conditionChanges).filter((key) => conditionChanges[key] === null);\n        const removedString =\n            removedConditions.length === 0\n                ? ''\n                : removedConditions.length === 1\n                ? `${removedConditions[0]}`\n                : removedConditions.length === 2\n                ? `${removedConditions.join(' or ')}`\n                : `${restoredList.slice(0, -1).join(', ')}, or ` + `${restoredList.slice(-1)[0]}`;\n        messages.push(removedConditions.length > 0 ? `No longer ${removedString}.` : null);\n\n        // Condition value reduction\n        const reducedConditions = Object.keys(conditionChanges).filter((key) =>\n            Number.isInteger(conditionChanges[key]),\n        );\n        const reducedString =\n            reducedConditions.length === 0\n                ? ''\n                : reducedConditions.length === 1\n                ? `${reducedConditions[0]} condition`\n                : `${reducedConditions.join(' and ')} conditions`;\n        messages.push(reducedConditions.length > 0 ? `${reducedString} reduced by 1.` : null);\n\n        // Send chat message with results\n        ChatMessage.create({\n            user: game.user.id,\n            content: messages.join(' '),\n            speaker: { alias: token.name },\n        });\n    }\n};\n\nnew Dialog({\n    title: 'Rest',\n    content: '<p>Rest for the night?</p>',\n    buttons: {\n        yes: {\n            icon: '<i class=\"fas fa-check\"></i>',\n            label: 'Rest',\n            callback: recover,\n        },\n        no: {\n            icon: '<i class=\"fas fa-times\"></i>',\n            label: 'Cancel',\n        },\n    },\n    default: 'yes',\n}).render(true);",
    "flags": {},
    "img": "icons/svg/sleep.svg",
    "name": "Rest for the Night",
    "permission": {
        "default": 0
    },
    "scope": "global",
    "type": "script"
}
