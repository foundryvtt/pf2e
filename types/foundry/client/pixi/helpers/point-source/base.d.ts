export {};

declare global {
    /**
     * A helper class used by the Sight Layer to represent a source of vision or illumination.
     * @param object The object responsible for the PointSource
     */
    abstract class PointSource<TObject extends PlaceableObject | undefined = PlaceableObject | undefined> {
        constructor(object: TObject);

        /** The PlaceableObject which is the origin of this PointSource. */
        object: TObject;

        /**
         * The type of source represented by this data structure.
         * Each subclass must implement this attribute.
         */
        static sourceType: string;

        /** A flag for whether this source is currently rendered or not. */
        active: boolean;

        /** The animation configuration applied to this source */
        animation: PointSourceAnimationConfiguration;

        /** The object of data which configures how this source is rendered */
        data: object;

        /** The maximum radius of emission for this source */
        radius: number;

        /** The restricted line-of-sight polygon that is generated by the origin and radius of this source. */
        los: PointSourcePolygon;

        /** PIXI Geometry generated to draw meshes. */
        protected _sourceGeometry: PIXI.Geometry | null;

        /** A Graphics object with pre-computed geometry used for masking based on line-of-sight. */
        losMask: PIXI.Graphics;

        /** Additional information which controls whether certain behaviors of the source must be enforced */
        protected _flags: Record<string, boolean | number>;

        /** To track meshes initialization */
        protected _meshesInit: boolean;

        /** The offset in pixels applied to create soft edges. */
        static EDGE_OFFSET: number;

        /** The x-coordinate of the point source origin. */
        get x(): number;

        /** The y-coordinate of the point source origin. */
        get y(): number;

        /** The type of source represented by this data structure. */
        get sourceType(): PointSourceType;

        /**
         * The elevation of the object bound to this base source, if any.
         * Returns the canvas primary background elevation otherwise.
         */
        get elevation(): number;

        /** If the source is animated or not. */
        get isAnimated(): boolean;

        /* -------------------------------------------- */
        /*  Point Source Methods                        */
        /* -------------------------------------------- */

        /**
         * A point is contained with the area of the source if it is within both the FOV circle and the LOS polygon.
         * @param point The point to test
         * @returns Is the point contained
         */
        containsPoint(point: Point): boolean;

        /** Steps that must be performed when the base source is destroyed. */
        destroy(): void;

        abstract initialize(data?: object): void;

        /** Refresh the state and uniforms of the BaseSource */
        refreshSource(): void;

        /* -------------------------------------------- */
        /*  Rendering                                   */
        /* -------------------------------------------- */

        /**
         * Create or update the source geometry with a polygon shape
         * Triangulate the form and create buffers
         * @param polygon The pixi polygon
         */
        protected _updateLosGeometry(polygon: PIXI.Polygon): void;

        /** Configure the parameters of the polygon that is generated for this source. */
        protected abstract _getPolygonConfiguration(): PointSourcePolygonConfig;

        /** Create the LOS polygon for this Light Source instance using provided parameters. */
        protected _createPolygon(): PointSourcePolygon;

        /**
         * Create or update the source geometry and create meshes if necessary
         * @param polygon A pixi polygon
         */
        protected _initializeMeshes(polygon: PIXI.Polygon): void;

        /**
         * Create a new Mesh for this source using a provided shader class
         * @param shaderCls The subclass of AdaptiveLightingShader being used for this Mesh
         * @returns The created Mesh
         */
        protected _createMesh(shaderCls: Function): PIXI.Mesh;

        /** Create all meshes needed with this PointSource */
        protected _createMeshes(): void;

        /**
         * Update the position and size of the mesh each time it is drawn.
         * @param mesh The Mesh being updated
         * @returns The updated Mesh
         */
        protected _updateMesh(mesh: PIXI.Mesh): PIXI.Mesh;

        /* -------------------------------------------- */
        /*  Animation Functions                         */
        /* -------------------------------------------- */

        /**
         * Animate the BaseSource, if an animation is enabled and if it currently has rendered containers.
         * @param dt Delta time.
         */
        animate(dt: number): void;
    }

    type PointSourceType = "light" | "sight";

    interface PointSourceAnimationConfiguration {
        /** The human-readable (localized) label for the animation */
        label?: string;
        /** The animation function that runs every frame */
        animation?: Function;
        /** A custom illumination shader used by this animation */
        illuminationShader?: PIXI.Shader;
        /** A custom coloration shader used by this animation */
        colorationShader?: PIXI.Shader;
        /** A custom background shader used by this animation */
        backgroundShader?: PIXI.Shader;
        /** The animation seed */
        seed?: number;
        /** The animation time */
        time?: number;
    }
}
